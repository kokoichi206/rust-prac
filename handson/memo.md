- C/C++ のメモリ管理の難しさを解決したい！
- Rust: さび
- rust-lang
  - https://github.com/rust-lang/rust
  - rust 自身も rust で書かれている！
- メモリ管理
  - python: GC
  - Rust: 所有権システム

## grammar

- `println!`
  - `!` は Rust の**マクロである**ことを示している
    - 普通の関数ではない
    - 他言語では、前処理・プリプロセッサと呼ばれる機能
  - マクロを利用することでデータ型を手軽に出力している
- 戻り値
  - `return 値;` or `値`
- 基本的に変数は値が immutable
  - 変更したいケースでは mut をつける
- **『文字』と『文字列』の区別**
  - 文字
    - 1 文字を表すデータ型
    - `'` で囲む
    - char
  - 文字列
    - 複数の文字を表すデータ型
    - `"` で囲む
    - &str
      - & は must? ppoi
      - String vs &str
- クロージャー
  - Python のラムダ式みたいなもん
- 可変配列
  - ベクター？
- expect, unwrap でエラー処理を簡略化することも可能だが、その場合は強制終了される
- Option 型
  - Some
  - None
- イテレータから直接データを取得することはできない
  - for 文などとの組み合わせが必要
  - Vector 型としておくと便利なことが！
- 配列
  - 要素の個数は変更できない
    - 変更したい場合は Vector を使う
  - スタック領域にメモリが確保されるため高速
- スライス型
  - 配列・ベクター・文字列などのデータ型の**要素の一部を参照**するためのもの
    - 参照であるため**スライスに所有権はない**
- 文字列
  - String 型はベクター
  - &str 型はスライス
  - マルチバイト文字のため、文字列から1文字取り出すのをインデックスアクセスではできない
    - `.chars()` or `.bytes()`
- lifetime
  - **値の参照が有効な範囲（スコープ）**
  - ライフタイム注釈記法（`'a`）
    - `&'static str` など

### 所有権: ownership

- メモリの有効性を検証
  - s1 -> s2 に移したりした時に、今現在どの変数が値を持ってるかとか
  - **borrow checker**
- **c++ のスマートポインターが参考にされている！**
- 三大原則
  - 値には『所有権』があって、**変数は値の『所有者』に**なれる
  - 所有権は移動するが『所有者』は1人（1つの変数）だけ
  - 『所有者』が有効スコープから出ると値は破棄される
- 所有権システムの例外となるケース
  - プリミティブ型！
    - **所有権が移動(move)されるのではなく、自動的に複製(copy)**になる
      - データサイズが決まっており、スタック領域に確保される
      - スタック領域のメモリは、最後に確保したデータから解放しなくてはならない！
  - Copy とレイトを実装したデータ型
- 複製すれば所有権は移動しない
- 借用
  - 値の所有権を一時的に借りる
  - 参照を表す『&』を指定する
  - **関数の引数に『参照』を指定することを『借用』と呼ぶ**
- lifetime
  - 関数の戻り値として参照を指定することはできない
    - スコープを出ると値は破棄される
  - 実態にすると返却できる！

## cargo

- パッケージマネージャーの機能も持つ
  - pip, npm
- ライブラリー（クレート）の管理
  - ライブラリ一覧
    - https://crates.io/

``` sh
cargo --help

cargo new hi
cargo run

cargo new test-example --lib
```

## メモ

- 値渡し
  - call by value
- 参照渡し
  - call by reference
- Rust
  - 参照渡しをするには & を指定
  - 値渡しをするときは所有権システムが適応
    - 基本型なら値がコピー
    - それ以外なら所有権の移動
- 乱数
  - [Xorshift](https://ja.wikipedia.org/wiki/Xorshift)
- `#[device (Clone)]`
  - Clone トレイト
- トレイト
  - インタフェースの機能ににている
  - デフォルトメソッドがある！
- ジェネリクス
  - なんでも取れるというわけではなく、トレイトを指定して絞り込んでいる！
    - コンパイル時に多くのことを気づくため
  - トレイト境界: trait bound
- イテレーター
  - for を使う際も所有権の移動に関して頭を使う必要がある！
  - method
    - iter
    - iter_mut
    - into_iter
- null 参照の発明は 10 億ドルにも相当する誤りだった
  - コンパイル時に判断できない
- **モジュール・クレート・パッケージ**
  - モジュールは木構造の表現
  - モジュールをまとめたものがクレート
  - クレートを管理するためのパッケージ
- クレート
  - モジュール木構造の頂点がクレートルート

``` sh
# --lib をつけると、ライブラリークレートになる！
cargo new rpn_calc --lib

cargo doc
```

- スレッド
  - mpsc チャンネル
    - 複数スレッド間で安全にデータを送受信するためのもの
- null 的な何か
  - Option
  - enum で空を表現
- `Rc<T>` 型
  - 参照カウンター方式のメモリ管理
  - ヒープ領域に値 T のメモリを確保する
    - `Box<T>` と同じ
  - **参照カウント方式でメモリを管理するため、1つのオブジェクトに対して複数の所有者を認めることができる！**
- 色んなジェネリクス
  - 参照カウンターを使う `Rc<T>`
  - コンパイル時には借用規則をチェックしない `RefCell<T>`
- **循環参照を避ける Weak 型**
  - `Rc<T>` が強い参照、`Weak<T>` が弱い参照
  - その時点では所有権を持たない
    - **弱い参照では、実際には値が削除されてしまっている可能性がある**
- `Arc<T>` は `Rc<T>` をスレッドセーフにしたもの

## マクロ

- **関数が実行時に動くのに対し、マクロはコンパイル前に実行されてプログラム自体を書き換える**
- 宣言的マクロ: declarative macro
  - 関数のように使える
- 手続的マクロ: procedural macro
  - 構造体に属性を与えた時に追加されるようなもの

## パーサージェネレーター

parser generator

- 文法を定義しておくと、その定義を元にコンパイラーを生成するツール
- コンパイラーを作成するコンパイラー
  - **コンパイラーコンパイラー**
- yacc など
- rust で著名なパーサージェネレーター
  - nom
  - lalprop
  - combine
  - peg
- PEG: Parsing Expression Grammar

## 疑問

- 参照（ポインター）を渡すこと → 所有権の借用との繋がりがわかってない
  - そういうもんと割り切る？
- lifetime の話も、実体にするとなんで解決するのか
