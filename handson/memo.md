- C/C++ のメモリ管理の難しさを解決したい！
- Rust: さび
- rust-lang
  - https://github.com/rust-lang/rust
  - rust 自身も rust で書かれている！
- メモリ管理
  - python: GC
  - Rust: 所有権システム

## grammar

- `println!`
  - `!` は Rust の**マクロである**ことを示している
    - 普通の関数ではない
    - 他言語では、前処理・プリプロセッサと呼ばれる機能
  - マクロを利用することでデータ型を手軽に出力している
- 戻り値
  - `return 値;` or `値`
- 基本的に変数は値が immutable
  - 変更したいケースでは mut をつける
- **『文字』と『文字列』の区別**
  - 文字
    - 1 文字を表すデータ型
    - `'` で囲む
    - char
  - 文字列
    - 複数の文字を表すデータ型
    - `"` で囲む
    - &str
      - & は must? ppoi
      - String vs &str
- クロージャー
  - Python のラムダ式みたいなもん
- 可変配列
  - ベクター？
- expect, unwrap でエラー処理を簡略化することも可能だが、その場合は強制終了される
- Option 型
  - Some
  - None
- イテレータから直接データを取得することはできない
  - for 文などとの組み合わせが必要
  - Vector 型としておくと便利なことが！
- 配列
  - 要素の個数は変更できない
    - 変更したい場合は Vector を使う
  - スタック領域にメモリが確保されるため高速
- スライス型
  - 配列・ベクター・文字列などのデータ型の**要素の一部を参照**するためのもの
    - 参照であるため**スライスに所有権はない**
- 文字列
  - String 型はベクター
  - &str 型はスライス
  - マルチバイト文字のため、文字列から1文字取り出すのをインデックスアクセスではできない
    - `.chars()` or `.bytes()`
- lifetime
  - **値の参照が有効な範囲（スコープ）**
  - ライフタイム注釈記法（`'a`）
    - `&'static str` など

### 所有権: ownership

- メモリの有効性を検証
  - s1 -> s2 に移したりした時に、今現在どの変数が値を持ってるかとか
  - **borrow checker**
- **c++ のスマートポインターが参考にされている！**
- 三大原則
  - 値には『所有権』があって、**変数は値の『所有者』に**なれる
  - 所有権は移動するが『所有者』は1人（1つの変数）だけ
  - 『所有者』が有効スコープから出ると値は破棄される
- 所有権システムの例外となるケース
  - プリミティブ型！
    - **所有権が移動(move)されるのではなく、自動的に複製(copy)**になる
      - データサイズが決まっており、スタック領域に確保される
  - Copy とレイトを実装したデータ型
- 複製すれば所有権は移動しない
- 借用
  - 値の所有権を一時的に借りる
  - 参照を表す『&』を指定する
  - **関数の引数に『参照』を指定することを『借用』と呼ぶ**
- lifetime
  - 関数の戻り値として参照を指定することはできない
    - スコープを出ると値は破棄される
  - 実態にすると返却できる！

## cargo

- パッケージマネージャーの機能も持つ
  - pip, npm
- ライブラリー（クレート）の管理
  - ライブラリ一覧
    - https://crates.io/

``` sh
cargo --help

cargo new hi
cargo run

cargo new test-example --lib
```

## メモ

- 値渡し
  - call by value
- 参照渡し
  - call by reference
- Rust
  - 参照渡しをするには & を指定
  - 値渡しをするときは所有権システムが適応
    - 基本型なら値がコピー
    - それ以外なら所有権の移動
- 乱数
  - [Xorshift](https://ja.wikipedia.org/wiki/Xorshift)
- `#[device (Clone)]`
  - Clone トレイト
- トレイト
  - インタフェースの機能ににている
  - デフォルトメソッドがある！
- ジェネリクス
  - なんでも取れるというわけではなく、トレイトを指定して絞り込んでいる！
    - コンパイル時に多くのことを気づくため
  - トレイト境界: trait bound
- イテレーター
  - for を使う際も所有権の移動に関して頭を使う必要がある！
  - method
    - iter
    - iter_mut
    - into_iter
- null 参照の発明は 10 億ドルにも相当する誤りだった
  - コンパイル時に判断できない
- **モジュール・クレート・パッケージ**
  - モジュールは木構造の表現
  - モジュールをまとめたものがクレート
  - クレートを管理するためのパッケージ
- クレート
  - モジュール木構造の頂点がクレートルート

``` sh
# --lib をつけると、ライブラリークレートになる！
cargo new rpn_calc --lib

cargo doc
```

- スレッド
  - mpsc チャンネル
    - 複数スレッド間で安全にデータを送受信するためのもの

## 疑問

- 参照（ポインター）を渡すこと → 所有権の借用との繋がりがわかってない
  - そういうもんと割り切る？
- lifetime の話も、実体にするとなんで解決するのか
